use Ref

static!

‣‣ times n:ℕ do:Fun
	doc
		Runs `do` `n` times.
	eg
		∙ r
			Ref 0
		times 3
			r.! _increment
		✔= 3
			r.get

	`
		for (var i = n; i > 0; i--)
			_do();

\ must get this here as use in JS will not trigger the use
∙ Some
	Opt.Some

‣‣ loop do:Fun
	doc
		Keep running fun until it returns Some.
		Then return the value in that Some.
	eg
		∙ a
			Ref 3
		∙ b
			Ref 0
		✔= 3
			loop
				a.! _decrement
				b.! _increment
				a.get.positive?.unless
					b.get
	err
		Infinite loop if Some never returned.

	`
		while (true) {
			var result = _do();
			if (Some['subsumes?'](result))
				return result.value();
		}

‣‣ while condition:Fun do:Fun
	doc
		Run `do` as long as `condition` holds.
	eg
		∙ a
			Ref 3
		∙ b
			Ref 0
		while
			a.get.positive?
		|
			a.! _decrement
			b.! _increment
		✔= 0
			a.get
		✔= 3
			b.get

	`
		while (condition())
			_do();

‣‣ do-while do:Fun condition:Fun
	doc
		Run `body`, then keep running it as long as `condition` holds.
	eg
		∙ a
			Ref 0
		do-while
			a.! _increment
		|
			Bool.⊥
		✔.fails
			do-while
				1
			|
				2
		✔= 1
			a.get

	`
		do {
			_do();
		}
		while (Bool().check('condition', condition()));

