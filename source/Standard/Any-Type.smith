use Singleton
use Str
use Fun

∙ T
	`_prelude['Any-Type']`

T.do

	‣ toString
		"<Type {name}>"

	‣ subsumes? a
		`a['__is-a-id-' + this._id] == true`

	‣ export exported
		`
			this.__exported = exported;

	‣ check name a
		`
			if (!(Object(name) instanceof String))
				throw new Error("First argument of 'check' must be a string");
			if (a == null)
				throw new Error("Undefined "+name+":"+this._name);
			if (!this['subsumes?'](a))
				throw new Error(name+' is not a '+this+'; is '+a);

	‣ to-type
		me

	‣ method name:Str
		`this.proto()[name]`
		#proto.property name

	‣ alias old-name:Str new-name:Str
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	# TODO: move to Singleton, does singleton
	‣ ‣‣ name:Str method:Fun
		`this[name] = method`

	‣ ‣val name:Str make-val:Fun
		me.‣‣ name make-val.cached

	‣ ‣read name:Str
		me.‣ name
			property "_{name}"

	‣ ‣write name:Str
		me.‣ "{name}!" |mod:Fun
			property! "_{name}" mod

	‣ ‣access name
		me.‣read name
		me.‣write name

	‣read name
	‣read super
	‣read proto
	‣read id
	‣read methods

	‣ test-all-eg
		methods.each-property |name method
			# TODO - try catch
			method.meta.eg.new-bound-call me

	‣ toString
		"<Type {name}>"

	‣ sub-type? type
		`true` #`(this === type) || ???`

	‣ no-instances!
		`console.log("Okay, no instances of "+this._name)`

	‣ type‣ name:Str super do-to
		∙ doto
			do-to
		∙ t
			()
		`
			if (doto == null) {
				t = T.of(name);
				doto = _super;
			}
			else {
				t = T.of(name, _super);
			}
			if (doto != null)
				t.do(doto);

		me.‣val name
			t

		t

	‣ object‣ name:Str super do-to
		∙ type
			me.type‣ name super do-to
		type.no-instances!
		type

	‣ ‣sub-type name:Str do-to:Fun
		type‣ name me do-to

	‣ ‣sub-object name:Str do-to:Fun
		object‣ name me do-to


		#∙ obj
		#	Singleton name
		#∙ doto
		#	do-to
		#`
		#	if (doto == null)
		#		obj.do(doto)

		#obj

#{
Singleton.do
	‣‣ of name:Str
		∙ type
			Type name
		type.do
			is Singleton
			+name
				name
		∙ single
			type.of
		single
}#

export T
