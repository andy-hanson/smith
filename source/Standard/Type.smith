#TODO: init

use Singleton

∙ T
	`_prelude.Type`

∙ defs |

	‣ method name#:String
		`this.proto()[name]`
		#proto.property name

	‣ alias old-name new-name#:String
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	‣ ‣read name#:String
		me.‣ name
			`this['_' + name]`

	‣read name
	‣read super
	‣read proto
	‣read id

	‣ self
		`this`

	‣ toString
		"<Type {name}>"

	‣ subsumes? a
		`a['__is-a-id-' + this._id] == true`

	‣ sub-type-id? typeid
		`this.__id == typeid || this.__parents.some(function(parent) {
			return parent['sub-type-id?'](typeid)
		})`

	‣ sub-type? type
		`true` #`(this === type) || ???`


	# TODO:
	# does Singleton

	me.‣ '‣‣ (Singleton.method '‣‣)
	me.‣ '‣val (Singleton.method 'val)

	‣ ‣type name do-to
		∙ type
			T name
		∙ doto
			do-to

		`(doto == null) ? null : type.do(doto)`
		type

	‣ ‣object name do-to
		∙ obj
			Singleton name
		∙ doto
			do-to
		#`(doto != null) ? obj.do(doto) : null`
		obj.do do-to

		obj


		#`console.log("Type " + this + " check " + a)`


defs.unbound.call T

#{
∙ fff |
	=+of |name
		∙ type
			Type name
		type.do
			is Singleton
			+name
				name
		∙ single
			type.of
		single

`fff.__unBound.call(Singleton)`
}#

export T
