∙ C
	Prelude@Any.class

C.do
	‣override-ok check name a
		`
			if (a == null)
				throw new global.Error("Undefined "+name+":"+this._name);
			if (!a[this['-id-check']]) {
				if (!(global.Object(name) instanceof String))
					throw new global.Error("First argument of 'check' must be a string");
				else
					throw new global.Error(name+' is not a '+this+'; is '+a+'; a '+a.class());
			}
			return a;

	‣override-ok export exported
		`
			if (exported == null)
				throw new global.Error('Exported nothing');
			if (this.__exported != null)
				throw new global.Error(this._name + ' already exported ' + this.__exported);
			this.__exported = exported;

	‣override-ok subsumes? a
		`a != null && a[this['-id-check']] === true`

	‣override-ok ‣ name:Str method:Fun
		doc
			TODO
		in
			`
				if (this._proto[name] != null) {
					var from =
						this._proto[name]._class;
					var fromStr =
						(from == null) ? '(from javascript code)' : ' from ' + from;
					throw new global.Error(this + ' already has method ' + name + fromStr);
				}

		me.‣override-ok name method

	‣ ‣override name:Str method:Fun
		doc
			TODO
		in
			`
				if (this._proto[name] == null)
					throw new global.Error('No need to override ' + name + ' in ' + this)

		me.‣override-ok name method

	‣ new ...args
		doc
			TODO
		in
			✔ (has-property? '_is-meta).¬

		∙ new
			Global@Object.create proto
		new.construct ...args
		new

	‣override toString
		doc
			TODO
		how
			TODO: name

		`this._name`

	‣ method name:Str
		doc
			This class' method of the given name.
			Does not include inherited methods.

		methods.property name

	‣ alias old-name:Str new-name:Str
		doc
			TODO

		∙ old
			old-name
		me.‣ new-name |...args
			`this[old].apply(this, args)`

	alias 'new 'of

	‣ ‣‣-maybe-override name:Str method:Fun
		doc
			TODO

		new! name method
		static-methods.new! name method


	‣ ‣‣ name:Str method:Fun
		doc
			Defines a method just for this class.
			Added to `static-methods` too.
			Not used by sub-classes.
		in
			✔ (has-proto-property? name).¬
				"{me.name}.{name} already defined, use ‣‣override"

		me.‣‣-maybe-override name method

	‣ ‣‣override name:Str method:Fun
		in
			✔ (has-proto-property? name)
				"{me.name}.{name} not defined, no need to override"

		me.‣‣-maybe-override name method

	‣ ‣val name:Str make-val:Fun
		doc
			Defines a lazy value on this class.

		me.‣‣ name make-val.cache

	‣ ‣method-meta name:Str fun:Fun
		how
			This is used before Bool is defined, so must be in JS.

		`
			if (fun._meta != null)
				this.method(name)['meta!'](fun._meta);
			return;

	∙ maybe-meta |method-name:Str ...meta
		∙ mn
			method-name
		`
			switch (meta.length) {
				case 0:
					break;
				case 1:
					this['‣method-meta'](mn, meta[0]);
					break;
				case 2:
					throw new global.Error(meta)
			}

		\(Opt.from-nullable meta).each
		\	me.‣method-meta method-name it

	‣ ‣read name:Str ...meta
		doc
			TODO

		me.‣ name
			property "_{name}"
		maybe-meta.call me name ...meta

	‣ ‣read~ name:Str ...meta
		doc
			TODO

		∙ method-name
			"{name}~"
		me.‣ method-name
			property~ "_{name}"
		maybe-meta.call me method-name ...meta

	‣ ‣read/~ ...args
		doc
			Both `read` and `read~`.

		me.‣read ...args
		me.‣read~ ...args

	‣ ‣write name:Str ...meta
		doc
			TODO

		me.‣ "{name}!" |mod:Fun
			modify-property! "_{name}" mod
		maybe-meta.call me "{name}!" ...meta
		me.‣ "set-{name}!" |new-value
			set-property! "_{name}" new-value
		maybe-meta.call me "set-{name}!" ...meta

	‣ ‣access name:Str ...meta
		doc
			TODO

		me.‣read name ...meta
		me.‣write name ...meta

	‣ ‣⚐ name:Str ...meta
		doc
			TODO

		me.‣ "{name}!"
			new! name 0
		maybe-meta.call me name ...meta
		me.‣ "not-{name}!"
			delete-property-if-exists! name
		me.‣ "{name}?"
			has-property? "_{name}"
		maybe-meta.call me "{name}?" ...meta

	\ by default classes are instantiable and non-extensible.

	‣⚐ instance-less

	‣⚐ extensible
		doc
			Whether I can have sub-classes.

	\‣ instantiable?
	\	doc
	\		Whether I can directly have instances.
	\		Sub-classes could be instantiable; if you want no sub-classes, use `static`.
	\	non-instantiable?.¬

	‣ abstract!
		instance-less!
		extensible!

	‣ static!
		doc
			Makes me non-instantiable and non-extensible.

		instance-less!
		not-extensible!

	‣read methods
		doc
			Dictionary of this class' own methods.
			Does not include inherited methods.

	‣read static-methods
		doc
			TODO

	‣read name
		doc
			Name of this class.

	‣read/~ super
		doc
			Super-class. Any does not have one, so you may want to use super~.

	‣read proto
		doc
			Instances of this class have this as their prototype.

	‣read id
		doc
			Unique number for this class.

	‣read traits
		doc
			TODO

	‣read trait-of
		doc
			TODO

	‣read super-of
		doc
			TODO

	‣read inherits-from
		doc
			TODO

	‣ super-of? class:C
		doc
			TODO

		super-of.∋ class

	‣ trait-of? class:C
		doc
			TODO

		trait-of.∋ class

	‣ inherits-from? class:C
		doc
			TODO

		\ can't use ∋ because Array needs to inherit it using trait
		(inherits-from.indexOf class).≠ -1

	me.‣ 'trait |new-trait:C
		in
			✔ (inherits-from? new-trait).¬
				"{me} already has trait {new-trait}"

		new-trait.trait-of.push me
		traits.push new-trait

		\ must use forEach because Array neads a trait to get each
		(new-trait.inherits-from.» new-trait).forEach |inherit-from ...ignore
			(inherits-from? inherit-from).unless!
				proto.new-unless-exists! "__is-a-id-{new-trait.id}"
					Bool.⊤
				inherits-from.push inherit-from
				inherit-from.methods.each-property |name value
					(name.identical? 'class).unless!
						✔ (proto.has-property? name).¬
							"{me} already has method {name}, can't inherit from {inherit-from}"
						proto.set-property! name value

	‣ meta
		(property~ '_meta).or
			Meta.from-maybe-pre (property~ '_make-meta-pre)

	‣ meta! mod:Fun
		set-property! '_meta (mod meta)

	‣ do-meta fun:Fun
		meta!
			it.merge fun.meta
		do fun

	‣ test-method! name:Str
		(method name).meta.test-eg![me]

	‣ test!
		doc
			Runs the `eg` of all of my static and instance methods.
			I am used as the delegate in the `eg`.

		✘.annotate
			meta.test-eg![me]
		|
			name

		∙ test |is-static
			|name method
				✘.annotate
					method.meta.test-eg![me]
				|
					∙ def
						is-static.?
							'‣‣
						|
							'‣
					"{me}{def}{name}"


		methods.each-property (test Bool.⊥)
		static-methods.each-property (test Bool.⊤)


	‣ sub-class? class:C
		doc
			Whether `class` inherits from me.
		eg
			✔ (Fun.sub-class? Any)
			✔ (Fun.sub-class? Str).¬
			✔ (Fun.sub-class? Fun)

		class.subsumes? proto

	‣ ‣class[super-class~:C] name:Str do-meta:Fun
		∙ args
			Array.proto@slice.call `arguments`
		∙ class
			C.of ...args
		me.‣val name
			class

		class

	‣ export-singleton[super-class~:C] do-meta:Fun
		∙ s
			super-class~.or
				Any-Class
		export (C.Singleton[s] name do-meta)

	‣ ‣object[super-class~:C] name:Str do-meta:Fun
		∙ args
			Array.proto@slice.call `arguments`
		me.‣val name
			C.Singleton ...args

	‣ ‣sub-class name:Str do-to:Fun
		me.‣class[me] name do-to

	‣ ‣sub-object name:Str do-to:Fun
		me.‣object[me] name do-to

	‣ data[can-extend~:Bool] constructor:Fun
		oth
			TODO:
			move elsewhere

		∙ can-extend
			can-extend~.or
				Bool.⊥
		\ arg, writable
		∙ names
			Global@Array.of
		∙ assigns
			Global@Array.of
		∙ mangled
			Global@Array.of

		∙  ctrArgs
			constructor.meta.arguments

		∙ useIndex |index
			∙ arg
				ctrArgs index
			∙ writable
				(arg.name.charAt 0).identical? '!
			∙ name
				writable.?
					arg.name.slice 1
				|
					arg.name
			∙ mangle
				Global@String.fromCharCode (('a.charCodeAt).+ index)

			me.‣read name
			writable.if!
				me.‣write name

			∙ assign
				"'_{name}': \{ value: {mangle}, writable: {writable} \}"

			\(Global@Array name assign)
			names.push name
			assigns.push assign
			mangled.push mangle

		`
			for (var index = 0; index < ctrArgs.size(); index++)
				useIndex(index);

		\∙ names
		\	names-assigns.map
		\∙ assigns
		\	names-assigns.map _second

		∙ assigns-str
			assigns.join ",\n\t"
		∙ maybe-no-extend
			can-extend.?
				""
			|
				"global.Object.preventExtensions(this);"
		∙ body
			"
				global.Object.defineProperties(this, \{
					{assigns-str}
				\});
				{maybe-no-extend}

		∙ define-properties
			Fun.from-JS mangled body

		‣ construct ...args
			define-properties.apply me args
			constructor.unbound.apply me args

	‣ ‣delegate name:Str delegate-to:Fun
		doc
			TODO

		∙ dt
			delegate-to.unbound
		me.‣ name |...args
			∙ delegated
				dt.call me
			`_c(delegated, name, [], [args])`
		\(method name).meta! delegate-to.meta

	‣ delegate-many names:Array delegate-to:Fun
		names.forEach |name ...ignore
			me.‣delegate name delegate-to

export C
