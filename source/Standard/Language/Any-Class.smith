∙ C
	Prelude@Any.class

C.do
	-def 'check |name a
		`
			if (!(global.Object(name) instanceof String))
				throw new global.Error("First argument of 'check' must be a string");
			if (a == null)
				throw new global.Error("Undefined "+name+":"+this._name);
			if (!this['subsumes?'](a))
				throw new global.Error(name+' is not a '+this+'; is '+a+'; a '+a.class());
			return a;

	-def '‣ |name:Str method:Fun
		`
			if (this._proto[name] != null)
				throw new global.Error(this + ' already has method ' + name)
		-def name method

	-def 'export |exported
		`
			this.__exported = exported;

	-def 'subsumes? |a
		`a['__is-a-id-' + this._id] == true`

	‣ ‣override name:Str method:Fun
		`
			if (this._proto[name] == null)
				throw new global.Error('No need to override ' + name + ' in ' + this)
		-def name method

	‣override toString
		how
			TODO: name

		`this._name`

	‣ to-class
		me

	‣ method name:Str
		methods.property name

	‣ alias old-name:Str new-name:Str
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	‣ ‣‣ name:Str method:Fun
		new! name method

	‣‣ of [super-class~:C] name:Str do-meta:Fun
		Prelude.class name super-class~.to-nullable do-meta

	‣‣ all-classes
		Prelude.all-classes

	‣ ‣val name:Str make-val:Fun
		me.‣‣ name make-val.cached

	‣ ‣method-meta name:Str fun:Fun
		how
			This is used before Bool is defined, so must be in JS.

		`
			if (fun._meta != null)
				this.method(name)['meta!'](fun._meta);
			return;

	∙ maybe-meta |method-name:Str meta
		∙ mn
			method-name
		`
			switch (meta.length) {
				case 0:
					break;
				case 1:
					this['‣method-meta'](mn, meta[0]);
					break;
				case 2:
					throw new global.Error(meta)
			}

		#(Opt.from-nullable meta).each
		#	me.‣method-meta method-name it

	‣ ‣read~ name:Str ...meta
		∙ method-name
			"{name}~"
		me.‣ method-name
			property~ "_{name}"
		maybe-meta.call me method-name meta

	‣ ‣read name:Str ...meta
		me.‣ name
			property "_{name}"
		maybe-meta.call me name meta

	‣ ‣read/~ ...args
		doc
			Both optional and forcing versions of a reader.

		me.‣read ...args
		me.‣read~ ...args

	‣ ‣write name:Str ...meta
		∙ method-name
			"{name}!"
		me.‣ method-name |mod:Fun
			modify-property! "_{name}" mod
		maybe-meta.call me method-name meta

	‣ ‣access name:Str meta
		me.‣read name meta
		me.‣write name meta

	‣read methods
		doc
			Dictionary of this class' own methods.
			Does not include inherited methods.

	‣read name
		doc
			Name of this class.

	‣read super
		doc
			Super-class.

	‣read proto
		doc
			Instances of this class have this as their prototype.

	‣read id
		doc
			Unique number for this class.

	‣ meta:Meta
		Meta.from-maybe-pre (property~ '_make-meta-pre)

	‣ meta! mod:Fun
		set-property! '_meta (mod meta)

	‣ do-meta fun:Fun
		meta!
			meta.merge fun.meta
		do fun

	‣ test!
		✘.annotate
			meta.test-eg![me]
		|
			"{me}#eg"

		methods.each-property |name method
			✘.annotate
				method.meta.test-eg![me]
			|
				"{me}#{name}#eg"

	‣ sub-class? class:C
		`true` #(this === class) || ???

	‣ no-instances!
		()

	‣ ‣class[super-class~:C] name:Str do-meta:Fun
		∙ args
			`arguments`
		∙ class
			C.of ...args
		me.‣val name
			class

		class

	‣ object‣ [super-class~:C] name:Str do-meta:Fun
		∙ args
			`arguments`
		∙ class
			me.‣class ...args
		∙ instance
			Global@Object.create class.proto
		class.‣‣ 'instance
			instance
		class.‣ constructor
			fail "Singleton class!"
		class.instance

	‣ ‣sub-class name:Str do-to:Fun
		me.‣class[me] name do-to

	‣ ‣sub-object name:Str do-to:Fun
		object‣[me] name do-to

	‣ data[can-extend~:Bool] constructor:Fun
		how
			TODO: mangle

		∙ can-extend
			can-extend~.or
				Bool.False
		# arg, writable
		∙ names-assigns
			constructor.meta.arguments.map |arg
				∙ writable
					(arg.name.char-at 0).= '!
				∙ name
					writable.?
						arg.name.tail
					|
						arg.name

				me.‣read name
				writable.if
					me.‣write name

				∙ assign
					"'_{name}': \{ value: {name}, writable: {writable} \}"

				(Bag name assign)
		∙ names
			names-assigns.map _first
		∙ assigns
			names-assigns.map _second
		∙ assigns-str
			assigns.join ",\n\t"
		∙ maybe-no-extend
			can-extend.?
				""
			|
				"global.Object.preventExtensions(this);"
		∙ body
			"
				global.Object.defineProperties(this, \{
					{assigns-str}
				\});
				{maybe-no-extend}

		∙ define-properties
			Fun.from-JS names  body

		‣ construct ...args
			define-properties.apply me args
			constructor.unbound.apply me args



export C
