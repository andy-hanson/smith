∙ C
	Prelude@Any.class

C.do
	-def 'check |name a
		`
			if (!(global.Object(name) instanceof String))
				throw new global.Error("First argument of 'check' must be a string");
			if (a == null)
				throw new global.Error("Undefined "+name+":"+this._name);
			if (!this['subsumes?'](a))
				throw new global.Error(name+' is not a '+this+'; is '+a+'; a '+a.class());
			return a;

	-def 'export |exported
		`
			if (exported == null)
				throw new global.Error('Exported nothing');
			if (this.__exported != null)
				throw new global.Error(this._name + ' already exported ' + this.__exported);
			this.__exported = exported;

	-def '‣ |name:Str method:Fun
		`
			if (this._proto[name] != null)
				throw new global.Error(this + ' already has method ' + name)
		-def name method

	-def 'subsumes? |a
		`a['__is-a-id-' + this._id] === true`

	‣ ‣override name:Str method:Fun
		`
			if (this._proto[name] == null)
				throw new global.Error('No need to override ' + name + ' in ' + this)
		-def name method

	‣override toString
		how
			TODO: name

		`this._name`

	‣ to-class
		me

	‣ method name:Str
		methods.property name

	‣ alias old-name:Str new-name:Str
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	‣ ‣‣ name:Str method:Fun
		new! name method
		\`this['_static-methods']
		static-methods.new! name method

	‣ ‣val name:Str make-val:Fun
		me.‣‣ name make-val.cached

	‣ ‣method-meta name:Str fun:Fun
		how
			This is used before Bool is defined, so must be in JS.

		`
			if (fun._meta != null)
				this.method(name)['meta!'](fun._meta);
			return;

	∙ maybe-meta |method-name:Str ...meta
		∙ mn
			method-name
		`
			switch (meta.length) {
				case 0:
					break;
				case 1:
					this['‣method-meta'](mn, meta[0]);
					break;
				case 2:
					throw new global.Error(meta)
			}

		\(Opt.from-nullable meta).each
		\	me.‣method-meta method-name it

	‣ ‣read~ name:Str ...meta
		∙ method-name
			"{name}~"
		me.‣ method-name
			property~ "_{name}"
		maybe-meta.call me method-name ...meta

	‣ ‣read name:Str ...meta
		me.‣ name
			property "_{name}"
		maybe-meta.call me name ...meta

	‣ ‣read/~ ...args
		doc
			Both optional and forcing versions of a reader.

		me.‣read ...args
		me.‣read~ ...args

	‣ ‣write name:Str ...meta
		∙ method-name
			"{name}!"
		me.‣ method-name |mod:Fun
			modify-property! "_{name}" mod
		maybe-meta.call me method-name ...meta

	‣ ‣access name:Str ...meta
		me.‣read name ...meta
		me.‣write name ...meta

	‣read methods
		doc
			Dictionary of this class' own methods.
			Does not include inherited methods.

	‣read static-methods
		doc
			TODO

	‣read name
		doc
			Name of this class.

	‣read/~ super
		doc
			Super-class. Any does not have one, so you may want to use super~.

	‣read proto
		doc
			Instances of this class have this as their prototype.

	‣read id
		doc
			Unique number for this class.

	‣read traits
		doc
			TODO

	‣read trait-of
		doc
			TODO

	‣read super-of
		doc
			TODO

	‣read inherits-from
		doc
			TODO

	‣ super-of? class:C
		doc
			TODO

		super-of.∋ class

	‣ trait-of? class:C
		doc
			TODO

		trait-of.∋ class

	‣ inherits-from? class:C
		doc
			TODO

		\ can't use ∋ because Array needs to inherit it using trait
		(inherits-from.indexOf class).≠ -1

	me.‣ 'trait |new-trait:C
		in
			✔ (inherits-from? new-trait).¬
				"{me} already has trait {new-trait}"

		new-trait.trait-of.push me
		traits.push new-trait

		\ must use forEach because Array neads a trait to get each
		(new-trait.inherits-from.+ new-trait).forEach |inherit-from
			(inherits-from? inherit-from).unless!
				proto.new-unless-exists! "__is-a-id-{new-trait.id}"
					Bool.⊤
				inherits-from.push inherit-from
				inherit-from.methods.each-property |name value
					(name.= 'class).unless!
						✔ (proto.has-property? name).¬
							"{me} already has method {name}, can't inherit from {inherit-from}"
						proto.set-property! name value

	‣ meta
		(property~ '_meta).or
			Meta.from-maybe-pre (property~ '_make-meta-pre)

	‣ meta! mod:Fun
		set-property! '_meta (mod meta)

	‣ do-meta fun:Fun
		meta!
			it.merge fun.meta
		do fun

	‣ test!
		✘.annotate
			meta.test-eg![me]
		|
			"{me}#eg"

		∙ f |is-static
			|name method
				✘.annotate
					method.meta.test-eg![me]
				|
					∙ hash
						is-static.?
							'##
						|
							'#
					"{me}{hash}{name}#eg"


		methods.each-property (f Bool.⊥)
		static-methods.each-property (f Bool.⊤)


	‣ sub-class? class:C
		doc
			TODO
		eg
			✔ (Fun.sub-class? Any)
			✔ (Fun.sub-class? Str).¬
			✔ (Fun.sub-class? Fun)

		class.subsumes? proto

	‣ no-instances!
		()

	‣ ‣class[super-class~:C] name:Str do-meta:Fun
		∙ args
			`arguments`
		∙ class
			C.of ...args
		me.‣val name
			class

		class

	‣ object‣ [super-class~:C] name:Str do-meta:Fun
		∙ args
			`arguments`
		∙ class
			me.‣class ...args
		∙ instance
			Global@Object.create class.proto
		class.‣‣ 'instance
			instance
		class.‣ constructor
			fail "Singleton class!"
		class.instance

	‣ ‣sub-class name:Str do-to:Fun
		me.‣class[me] name do-to

	‣ ‣sub-object name:Str do-to:Fun
		object‣[me] name do-to

	‣ data[can-extend~:Bool] constructor:Fun
		todo
			mangle
			move elsewhere

		∙ can-extend
			can-extend~.or
				Bool.⊥
		\ arg, writable
		∙ names
			Global@Array.of
		∙ assigns
			Global@Array.of
		∙ names-assigns
			constructor.meta.arguments.map |arg
				∙ writable
					(arg.name.charAt 0).= '!
				∙ name
					writable.?
						arg.name.slice 1
					|
						arg.name

				me.‣read name
				writable.if!
					me.‣write name

				∙ assign
					"'_{name}': \{ value: {name}, writable: {writable} \}"

				\(Global@Array name assign)
				names.push name
				assigns.push assign
		\∙ names
		\	names-assigns.map
		\∙ assigns
		\	names-assigns.map _second
		∙ assigns-str
			assigns.join ",\n\t"
		∙ maybe-no-extend
			can-extend.?
				""
			|
				"global.Object.preventExtensions(this);"
		∙ body
			"
				global.Object.defineProperties(this, \{
					{assigns-str}
				\});
				{maybe-no-extend}

		∙ define-properties
			Fun.from-JS names  body

		‣ construct ...args
			define-properties.apply me args
			constructor.unbound.apply me args

	‣ ‣delegate name:Str delegate-to:Fun
		doc
			TODO

		∙ dt
			delegate-to.unbound
		me.‣ name |...args
			∙ delegated
				dt.call me
			\delegated.send name ...args
			`_call(delegated, name, [], [args])`
		\(method name).meta! delegate-to.meta

	‣ delegate-many names:Array delegate-to:Fun
		names.forEach |name
			me.‣delegate name delegate-to

export C
