∙ C
	`_prelude`@Any.class

C.do
	-def 'check |name a
		`
			if (!(global.Object(name) instanceof String))
				throw new global.Error("First argument of 'check' must be a string");
			if (a == null)
				throw new global.Error("Undefined "+name+":"+this._name);
			if (!this['subsumes?'](a))
				throw new global.Error(name+' is not a '+this+'; is '+a);
			return a;

	-def '‣ |name:Str method:Fun
		`
			if (this._proto[name] != null)
				throw new global.Error(this + ' already has method ' + name)
		-def name method

	-def 'export |exported
		`
			this.__exported = exported;

	-def 'subsumes? |a
		`a['__is-a-id-' + this._id] == true`

	‣ ‣override name:Str method:Fun
		`
			if (this._proto[name] == null)
				throw new global.Error('No need to override ' + name + ' in ' + this)
		-def name method

	‣override toString
		how
			TODO: name

		`this._name`

	‣ to-class
		me

	‣ do-meta fun:Fun
		meta!
			it.merge fun.meta
		do fun

	‣ method name:Str
		methods.property name

	‣ alias old-name:Str new-name:Str
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	‣ ‣‣ name:Str method:Fun
		`this[name] = method`

	‣‣ all-classes
		`_prelude`.all-classes

	‣ ‣val name:Str make-val:Fun
		me.‣‣ name make-val.cached

	‣ ‣method-meta name:Str fun:Fun
		how
			This is used before Bool is defined, so must be in JS.

		`
			if (fun._meta != null)
				this.method(name)['meta!'](fun._meta);
			return;

	‣ ‣read~ name:Str meta:Fun
		∙ method-name
			"{name}~"
		me.‣ method-name
			property~ "_{name}"
		me.‣method-meta method-name meta

	‣ ‣read name:Str meta:Fun
		me.‣ name
			property "_{name}"
		me.‣method-meta name meta

	‣ ‣read/~ name:Str meta:Fun
		doc
			Both optional and forcing versions of a reader.

		me.‣read name meta
		me.‣read~ name meta

	‣ ‣write name:Str meta:Fun
		∙ method-name
			"{name}!"
		me.‣ method-name |mod:Fun
			modify-property! "_{name}" mod
		me.‣method-meta method-name meta

	‣ ‣access name:Str meta:Fun
		me.‣read name meta
		me.‣write name meta


	‣read methods
		doc
			Dictionary of this class' own methods.
			Does not include inherited methods.

	‣read name
		doc
			Name of this class.

	‣read super
		doc
			Super-class.

	‣read proto
		doc
			Instances of this class have this as their prototype.

	‣read id
		doc
			Unique number for this class.

	‣ meta
		(property~ '_meta).or
			Meta.Empty

	‣ meta! mod:Fun
		set-property! '_meta (mod meta)

	‣ test!
		✘.annotate
			meta.test-eg!
		|
			"{me}#eg"

		methods.each-property |name method
			✘.annotate
				method.meta.test-eg!
			|
				"{me}#{name}#eg"

	‣ sub-class? class:C
		`true` #(this === class) || ???

	‣ no-instances!
		()

	‣ class‣ name:Str super-class do-to
		∙ doto
			do-to
		∙ sc
			super-class
		∙ c
			()
		`
			if (doto == null) {
				c = C.of(name);
				doto = sc;
			}
			else {
				c = C.of(name, sc);
			}
			if (doto != null)
				c.do(doto);

		me.‣val name
			c

		c

	‣ object‣ name:Str super-class do-to
		∙ class
			me.class‣ name super-class do-to
		class.no-instances!
		class

	‣ ‣sub-class name:Str do-to:Fun
		me.class‣ name me do-to

	‣ ‣sub-object name:Str do-to:Fun
		object‣ name me do-to



export C
