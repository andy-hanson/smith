∙ C
	Prelude@Any.class

C.do
	-def 'check |name a
		`
			if (!(global.Object(name) instanceof String))
				throw new global.Error("First argument of 'check' must be a string");
			if (a == null)
				throw new global.Error("Undefined "+name+":"+this._name);
			if (!this['subsumes?'](a))
				throw new global.Error(name+' is not a '+this+'; is '+a+'; a '+a.class());
			return a;

	-def 'export |exported
		`
			if (exported == null)
				throw new global.Error('Exported nothing');
			if (this.__exported != null)
				throw new global.Error(this._name + ' already exported ' + this.__exported);
			this.__exported = exported;

	-def '‣ |name:Str method:Fun
		`
			if (this._proto[name] != null)
				throw new global.Error(this + ' already has method ' + name)
		-def name method

	-def 'subsumes? |a
		`a['__is-a-id-' + this._id] === true`

	‣ ‣override name:Str method:Fun
		`
			if (this._proto[name] == null)
				throw new global.Error('No need to override ' + name + ' in ' + this)
		-def name method

	‣override toString
		how
			TODO: name

		`this._name`

	‣ to-class
		me

	‣ method name:Str
		methods.property name

	‣ alias old-name:Str new-name:Str
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	‣ ‣‣ name:Str method:Fun
		new! name method
		\`this['_static-methods']
		static-methods.new! name method

	‣ ‣val name:Str make-val:Fun
		me.‣‣ name make-val.cached

	‣ ‣method-meta name:Str fun:Fun
		how
			This is used before Bool is defined, so must be in JS.

		`
			if (fun._meta != null)
				this.method(name)['meta!'](fun._meta);
			return;

	∙ maybe-meta |method-name:Str ...meta
		∙ mn
			method-name
		`
			switch (meta.length) {
				case 0:
					break;
				case 1:
					this['‣method-meta'](mn, meta[0]);
					break;
				case 2:
					throw new global.Error(meta)
			}

		\(Opt.from-nullable meta).each
		\	me.‣method-meta method-name it

	‣ ‣read~ name:Str ...meta
		∙ method-name
			"{name}~"
		me.‣ method-name
			property~ "_{name}"
		maybe-meta.call me method-name ...meta

	‣ ‣read name:Str ...meta
		me.‣ name
			property "_{name}"
		maybe-meta.call me name ...meta

	‣ ‣read/~ ...args
		doc
			Both optional and forcing versions of a reader.

		me.‣read ...args
		me.‣read~ ...args

	‣ ‣write name:Str ...meta
		∙ method-name
			"{name}!"
		me.‣ method-name |mod:Fun
			modify-property! "_{name}" mod
		maybe-meta.call me method-name ...meta

	‣ ‣access name:Str ...meta
		me.‣read name ...meta
		me.‣write name ...meta

	‣read methods
		doc
			Dictionary of this class' own methods.
			Does not include inherited methods.

	‣read static-methods
		doc
			TODO

	‣read name
		doc
			Name of this class.

	‣read/~ super
		doc
			Super-class. Any does not have one, so you may want to use super~.

	‣read proto
		doc
			Instances of this class have this as their prototype.

	‣read id
		doc
			Unique number for this class.

	‣read traits
		doc
			TODO

	‣read trait-of
		doc
			TODO

	‣read super-of
		doc
			TODO

	‣read inherits-from
		doc
			TODO

	‣ inherits-from? class:C
		inherits-from.∋ class

	me.‣ 'trait |new-trait:C
		traits.push new-trait

		(new-trait.inherits-from.+ new-trait).each |inherit-from
			(inherits-from? inherit-from).unless!
				inherits-from.push inherit-from
				inherit-from.methods.each-property |name value
					(name.= 'class).unless!
						proto.new! name value

		inherits-from.push new-trait



	‣ meta
		(property~ '_meta).or
			Meta.from-maybe-pre (property~ '_make-meta-pre)

	‣ meta! mod:Fun
		set-property! '_meta (mod meta)

	‣ do-meta fun:Fun
		meta!
			it.merge fun.meta
		do fun

	‣ test!
		✘.annotate
			meta.test-eg![me]
		|
			"{me}#eg"

		∙ f |is-static
			|name method
				✘.annotate
					method.meta.test-eg![me]
				|
					∙ hash
						is-static.?
							'##
						|
							'#
					"{me}{hash}{name}#eg"


		methods.each-property (f Bool.⊥)
		static-methods.each-property (f Bool.⊤)



	‣ instances-are? class:C
		eg
			✔ (Fun.instances-are? Any)
			✔ (Fun.instances-are? Str).¬
			✔ (Fun.instances-are? Fun)

		class.subsumes? proto

	‣ no-instances!
		()

	‣ ‣class[super-class~:C] name:Str do-meta:Fun
		∙ args
			`arguments`
		∙ class
			C.of ...args
		me.‣val name
			class

		class

	‣ object‣ [super-class~:C] name:Str do-meta:Fun
		∙ args
			`arguments`
		∙ class
			me.‣class ...args
		∙ instance
			Global@Object.create class.proto
		class.‣‣ 'instance
			instance
		class.‣ constructor
			fail "Singleton class!"
		class.instance

	‣ ‣sub-class name:Str do-to:Fun
		me.‣class[me] name do-to

	‣ ‣sub-object name:Str do-to:Fun
		object‣[me] name do-to

	‣ data[can-extend~:Bool] constructor:Fun
		todo
			mangle
			move elsewhere

		∙ can-extend
			can-extend~.or
				Bool.⊥
		\ arg, writable
		∙ names-assigns
			constructor.meta.arguments.map |arg
				∙ writable
					(arg.name.char-at 0).= '!
				∙ name
					writable.?
						arg.name.tail
					|
						arg.name

				me.‣read name
				writable.if!
					me.‣write name

				∙ assign
					"'_{name}': \{ value: {name}, writable: {writable} \}"

				(Bag name assign)
		∙ names
			names-assigns.map _first
		∙ assigns
			names-assigns.map _second
		∙ assigns-str
			assigns.join ",\n\t"
		∙ maybe-no-extend
			can-extend.?
				""
			|
				"global.Object.preventExtensions(this);"
		∙ body
			"
				global.Object.defineProperties(this, \{
					{assigns-str}
				\});
				{maybe-no-extend}

		∙ define-properties
			Fun.from-JS names  body

		‣ construct ...args
			define-properties.apply me args
			constructor.unbound.apply me args

export C
