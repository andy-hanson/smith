∙ C
	`_prelude['Any-Class']`

C.do
	-def 'check |name a
		`
			if (!(global.Object(name) instanceof String))
				throw new global.Error("First argument of 'check' must be a string");
			if (a == null)
				throw new global.Error("Undefined "+name+":"+this._name);
			if (!this['subsumes?'](a))
				throw new global.Error(name+' is not a '+this+'; is '+a);
			return a;

	-def '‣ |name:Str method:Fun
		`
			if (this._proto[name] != null)
				throw new global.Error(this + ' already has method ' + name)
		-def name method

	-def 'export |exported
		`
			this.__exported = exported;

	-def 'subsumes? |a
		`a['__is-a-id-' + this._id] == true`

	‣ ‣override name:Str method:Fun
		`
			if (this._proto[name] == null)
				throw new global.Error('No need to override ' + name + ' in ' + this)
		-def name method

	‣override toString
		how
			TODO: name

		`this._name`

	‣ to-class
		me

	‣ do-meta fun:Fun
		meta!
			it.merge fun.meta
		do fun

	‣ method name:Str
		methods.property name

	‣ alias old-name:Str new-name:Str
		∙ old
			old-name
		me.‣ new-name
			`this[old].apply(this, arguments)`

	‣ ‣‣ name:Str method:Fun
		`this[name] = method`

	‣‣ all-classes
		`_prelude`.all-classes

	‣ ‣val name:Str make-val:Fun
		me.‣‣ name make-val.cached

	‣ ‣method-meta name:Str fun:Fun
		how
			blsah

		`
			if (fun._meta != null)
				this.method(name)['meta!'](fun._meta);
			return null;

	‣ ‣read~ name:Str meta:Fun
		∙ method-name
			"{name}~"
		me.‣ method-name
			property~ "_{name}"
		me.‣method-meta method-name meta

	‣ ‣read name:Str meta:Fun
		me.‣ name
			property "_{name}"
		me.‣method-meta name meta

	‣ ‣read/~ name:Str meta:Fun
		doc
			Both optional and forcing versions of a reader.

		me.‣read name meta
		me.‣read~ name meta

	‣ ‣write name:Str meta:Fun
		∙ method-name
			"{name}!"
		me.‣ method-name |mod:Fun
			modify-property! "_{name}" mod
		me.‣method-meta method-name meta

	‣ ‣access name:Str meta:Fun
		me.‣read name meta
		me.‣write name meta

	‣ meta
		(property~ '_meta).or
			Meta.Empty

	‣ meta! mod:Fun
		set-property! '_meta (mod meta)


	‣ test!
		✘.annotate
			meta.test-eg!
		|
			"{me}#eg"

		methods.each-property |name method
			✘.annotate
				method.meta.test-eg!
			|
				"{me}#{name}#eg"

	‣ sub-class? class:C
		`true` #(this === class) || ???

	‣ no-instances!
		()

	‣ class‣ name:Str super-class do-to
		∙ doto
			do-to
		∙ sc
			super-class
		∙ c
			()
		`
			if (doto == null) {
				c = C.of(name);
				doto = sc;
			}
			else {
				c = C.of(name, sc);
			}
			if (doto != null)
				c.do(doto);

		me.‣val name
			c

		c

	‣ object‣ name:Str super-class do-to
		∙ class
			me.class‣ name super-class do-to
		class.no-instances!
		class

	‣ ‣sub-class name:Str do-to:Fun
		me.class‣ name me do-to

	‣ ‣sub-object name:Str do-to:Fun
		object‣ name me do-to



export C
