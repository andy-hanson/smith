∙ A
	`_prelude.Any`

A.do
	‣override class
		doc
			if not overridden...

		(property 'constructor).to-class

	‣ has-property? name:Str
		`Object.prototype.hasOwnProperty`.call me name

	‣ property name:Str
		how
			must be in JS because fundamental methods depend on this.

		`
			if (Object.prototype.hasOwnProperty.call(this, name))
				return this[name];
			else
				throw new global.Error("" + this + " does not have property " + name);

	‣ property~ name:Str
		(has-property? name).if
			∙ h
				`this[name]`
			✔ (A.exists? h)
				"Object has key {name} but no value"
			h

	‣ property-names
		Global@Object.getOwnPropertyNames me

	‣ show-properties
		`
			var s = "{", me = this;
			Object.getOwnPropertyNames(this).forEach(function(key) {
				s += key + ': ' + global.String(me[key]) + ',';
			});
			return s + "}";

	‣‣ exists? a
		`a != null`

	‣ each-property fun:Fun
		property-names.each |name
			fun name (property name)

	‣ new-mutable! name:Str value
		✔ (has-property? name).¬
		set-property! name value

	‣ new! name:Str value
		doc
			Defines a new immutable property on this object.
		how
			Writable is false by default.

		`global.Object.defineProperty(this, name, {value: value})`

	‣ set-property! name:Str value
		`this[name] = value`

	‣ modify-property! name:Str mod:Fun
		∙ old
			property name
		∙ new
			mod old
		set-property! name new

	‣ is-a class:Any-Class
		class.subsumes? me

	‣ identical? a
		`this === a`

	‣ structural-= a
		(class.= a.class).∧
			∙ keys
				property-names

			(keys.size.= a.property-names.size).∧
				keys.every
					(property it).= (a.property it)

			#{`
				var meKeys = global.Object.getOwnPropertyNames(this);
				var aKeys = global.Object.getOwnPropertyNames(a);
				if (meKeys.length != aKeys.length)
					return false;
				return meKeys.every(function(key) {
					return this[key]['='](a[key]);
				})
			}#

	‣ = a
		identical? a

	‣ ≠ a
		(= a).¬

	‣ send name:Str ...args
		`this[name].apply(this, args)`

export A
