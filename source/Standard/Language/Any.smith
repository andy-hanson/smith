∙ A
	Prelude@Any

A.do
	\‣override class
	\	doc
	\		if not overridden...
	\
	\	(property 'constructor).to-class

	‣ has-property? name:Str
		doc
			TODO

		`Object.prototype.hasOwnProperty`.call me name

	‣ proto-property name:Str
		doc
			TODO

		`this[name]`

	‣ property name:Str
		doc
			TODO
		how
			must be in JS because fundamental methods depend on this.

		`
			if (global.Object.prototype.hasOwnProperty.call(this, name))
				return this[name];
			else
				throw new global.Error("" + this + " does not have property " + name);

	‣ property~ name:Str
		doc
			TODO

		(has-property? name).if
			∙ h
				`this[name]`
			✔ (A.exists? h)
				"Object has key {name} but no value"
			h

	‣ property-names
		doc
			TODO

		Global@Object.getOwnPropertyNames me

	‣ show-properties
		doc
			TODO

		`
			var s = "{", me = this;
			Object.getOwnPropertyNames(this).forEach(function(key) {
				s += key + ': ' + global.String(me[key]) + ',';
			});
			return s + "}";

	‣‣ exists? a
		doc
			TODO

		`a != null`

	‣ each-property fun:Fun
		doc
			TODO

		\ must use forEach because defining Array requires this
		property-names.forEach |name
			fun name (property name)

	‣ new-mutable! name:Str value
		doc
			TODO

		✔ (has-property? name).¬
		set-property! name value

	‣ set-property! name:Str value
		doc
			TODO

		`this[name] = value`

	‣ new-unless-exists! name:Str make-value:Fun
		doc
			TODO

		(has-property? name).unless!
			new! name make-value.of

	‣ modify-property! name:Str mod:Fun
		doc
			TODO

		∙ old
			property name
		∙ new
			mod old
		set-property! name new

	‣ is-a class:Any-Class
		doc
			TODO

		class.subsumes? me

	‣ identical? a
		doc
			TODO

		`this === a`

	‣ structural-= a
		doc
			TODO

		(class.= a.class).∧
			∙ keys
				property-names

			(keys.size.= a.property-names.size).∧
				keys.every
					(property it).= (a.property it)

			\`
			\	var meKeys = global.Object.getOwnPropertyNames(this);
			\	var aKeys = global.Object.getOwnPropertyNames(a);
			\	if (meKeys.length != aKeys.length)
			\		return false;
			\	return meKeys.every(function(key) {
			\		return this[key]['='](a[key]);
			\	})

	‣ = a
		doc
			TODO

		identical? a

	‣ ≠ a
		doc
			Not =.

		(= a).¬

	‣ send name:Str ...args
		doc
			TODO

		(proto-property name).apply me args

export A
