∙ A
	Prelude@Any

A.do
	\‣override class
	\	doc
	\		if not overridden...
	\
	\	(property 'constructor).to-class

	‣ has-property? name:Str
		doc
			TODO

		`Object.prototype.hasOwnProperty`.call me name

	‣ proto-property name:Str
		doc
			TODO

		`this[name]`

	‣ unsafe-property name:Str
		doc
			May return undefined.

		`this[name]`

	‣ property name:Str
		doc
			TODO
		how
			must be in JS because fundamental methods depend on this.

		`
			if (global.Object.prototype.hasOwnProperty.call(this, name))
				return this[name];
			else
				throw new global.Error("" + this + " does not have property " + name);

	‣ property~ name:Str
		doc
			TODO

		(has-property? name).if
			∙ h
				`this[name]`
			✔ (A.exists? h)
				"Object has key {name} but no value"
			h

	‣ property-names:Array
		doc
			TODO
		err
			TypeError if I'm a value type.

		Global@Object.getOwnPropertyNames me

	‣ show-properties:Str
		doc
			TODO

		`
			var s = "{", me = this;
			Object.getOwnPropertyNames(this).forEach(function(key) {
				s += key + ': ' + global.String(me[key]) + ',';
			});
			return s + "}";

	‣‣ exists?:Bool a
		doc
			TODO

		`a != null`

	‣ each-property fun:Fun
		doc
			TODO
		todo
			property-iterator

		\ must use forEach because defining Array requires this
		property-names.forEach |name ...ignore
			fun name (property name)

	‣ new-mutable! name:Str value
		doc
			TODO

		✔ (has-property? name).¬
		set-property! name value

	‣ set-property! name:Str value
		doc
			TODO

		`this[name] = value`

	‣ new-unless-exists! name:Str make-value:Fun
		doc
			TODO

		(has-property? name).unless!
			new! name make-value.of

	‣ modify-property! name:Str mod:Fun
		doc
			TODO

		∙ old
			property name
		∙ new
			mod old
		set-property! name new

	\‣ is-a?:Bool class:Any-Class
	\	doc
	\		TODO

	\	class.subsumes? me

	‣ identical?:Bool a
		doc
			Whether I and a are the very same object, at the same place in memory.
			For testing whether we are the same in every respect, use `structual-=`.
		eg
			∙ a
				Opt.some 1
			✔ (a.identical? a)
			✔ (a.identical? (Opt.some 3)).¬
			✔ ("123".identical? "123")

		`this === a`

	‣ structural-=:Bool a
		doc
			Whether I and `a` have equal (by calling `=`) properties and are of the same class.
		eg
			∙ a
				Opt.some 1
			✔ (a.structural-= (Opt.some 1))
			✔ (a.structural-= (Opt.some 2)).¬
			✔ (a.structural-= `{ _value: 1 }`).¬

		(class.= a.class).∧
			∙ keys
				property-names

			keys.∀ |key
				(a.has-property? key).∧
					(property key).= (a.property key)

		\`
		\	if (this.class() !== a.class())
		\		return false;
		\	var meKeys = global.Object.getOwnPropertyNames(this);
		\	var aKeys = global.Object.getOwnPropertyNames(a);
		\	if (meKeys.length != aKeys.length)
		\		return false;
		\	return meKeys.every(function(key) {
		\		return this[key]['='](a[key]);
		\	})

	‣ =:Bool a
		doc
			TODO

		(identical? a).∨
			structural-= a

	‣ ≠ a
		doc
			Not `=`.

		(= a).¬

	‣ send name:Str ...args
		doc
			Calls the method of the name on the arguments.
		eg
			✔= 3
				1.send '+ 2

		(proto-property name).apply me args

export A
