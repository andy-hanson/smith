(use ℝ).do
	‣ round-towards-0
		doc
			Rounds down if positive, rounds up if negative.
		eg
			✔= 0
				-0.5.round-towards-0
			✔= 0
				0.5.round-towards-0

		binary-or 0

	‣ round
		doc
			Nearest integer to me.
			Rounds up when halfway between two integers.
		eg
			✔= 0
				-0.5.round
			✔= 1
				0.5.round

		Global@Math.round me

	‣ round-down:ℤ
		doc
			Highest integer lower than me.
		eg
			✔= -1
				-0.5.round-down
			✔= 0
				0.5.round-down

		Global@Math.floor me

	‣ round-up:ℤ
		doc
			Lowest integer higher than me.
		eg
			✔= 0
				-0.5.round-up
			✔= 1
				0.5.round-up

		Global@Math.ceil me

	‣ remainder:ℝ divisor:ℝ
		doc
			Remainder after division.
		eg
			✔= 1
				3.remainder 2

		`this % divisor`

	‣ ℕ?
		doc
			Am I a natural number, a non-negative integer?
		eg
			✔ 0.ℕ?
			✔ -1.ℕ?.¬

		ℤ?.∧
			negative?.¬

	‣ ℤ?
		doc
			Am I an integer, do I have no fractional parts?
		eg
			✔ 42.ℤ?
			✔ 0.5.ℤ?.¬
			✔ ∞.ℤ?.¬
			✔ Not-A-Number.ℤ?.¬
		how
			TODO: Number.isInteger

		finite?.∧
			(in-range -9007199254740992 9007199254740992).∧
				= (Global@Math.floor me)

	‣ divisible? divisor:ℝ
		doc
			Whether an ingeger number of divisor can add up to me.
		eg
			✔ (4.divisible? 2)
			✔ (4.divisible? -2)
			✔ (3.divisible? 2).¬

		(remainder divisor).zero?

	‣ even?
		divisible? 2

	‣ odd?
		even?.¬

	‣ decrement
		doc
			One less than me.
		eg
			✔= 1.5
				2.5.decrement
		- 1

	‣ increment
		doc
			One more than me.
		eg
			✔= 2.5
				1.5.increment
		+ 1

	‣ factorial
		doc
			Product of all integers up to me.
		in
			✔ ℕ?
		\TODO
		\eg
		\	✔= 6
		\		3.factorial
		\	✔= 1
		\		0.factorial
		\	✔.fails
		\		-1.factorial
		\	✔.fails
		\		0.5.factorial

		(Range 1 increment).fold _×

	‣ greatest-common-divisor a:ℕ
		doc
			Highest integer that both I and `a` are divisible by.
		in
			✔ ℕ?
		eg
			✔= 6
				12.greatest-common-divisor 18
		out
			res.divisible? me
			res.divisible? a

		(a.= 0).?
			me
		|
			a.greatest-common-divisor (remainder a)

	‣ least-common-multiple a:ℕ
		doc
			Lowest integer that both I and `a` are factors of.
		in
			✔ ℕ?
		out
			me.divisible? res
			a.divisible? res
		eg
			✔= 18
				6.least-common-multiple 9

		(× a).÷ (greatest-common-divisor a)

	‣ whole-÷ divisor:ℝ
		doc
			Like ÷, but any fractional part is rounded down. _Not_ necessarily rounded towards 0.
		eg
			✔= 1
				3.whole-÷ 2
			✔= -2
				3.whole-÷ -2

		(÷ divisor).round-down

	‣ divide-evenly~ divisor:ℝ
		doc
			If possible, an integer which × divisor is me.
		eg
			✔= Opt.None
				3.divide-evenly~ 2
			\✔= (Opt.some 2)
			\	4.divide-evenly~ 2
		how
			TODO: Some equality

		Opt.filter (÷ divisor) _ℤ?

	‣ binary-or:ℤ n:ℤ
		`this | n`

	‣ binary-and:ℤ n:ℤ
		`this & n`

	‣ binary-xor:ℤ n:ℤ
		`this ^ n`

	‣ binary-not:ℤ
		`~this`

	‣ binary-shift-left:ℤ n:ℤ
		`this << n`

	‣ binary-shift-right-signed:ℤ n:ℤ
		`this >> n`

	‣ binary-shift-right-unsigned:ℤ n:ℤ
		`this >>> n`
