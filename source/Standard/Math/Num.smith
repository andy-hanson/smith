use Opt

∙ N
	`global.Number`.to-type 'Num

∙ JS-Math
	`global.Math`

N.do
	‣ round
		doc
			Nearest integer to this number.
			Rounds up when halfway between two integers.
		eg
			✔ 1
				round 0.5
			✔ 0
				-1
				round -0
				round -0.5

		JS-Math.round me

	‣ round-down
		eg
			✔ -1
				round-down -0.5
			✔ 0
				round-down 0.5
		JS-Math.floor me

	‣ round-up
		eg
			✔ 0
				round-up -0.5
			✔ 1
				round-up 0.5
		JS-Math.ceil me

	‣ abs
		JS-Math.abs me

	‣ acos
		JS-Math.acos me

	‣ cos
		eg
			✔ 1
				0.cos
			✔ 0
				π/2.cos
			✔ -1
				π.sin
			✔ 0
				π3/2.sin
		JS-Math.cos me

	‣ sin
		eg
			✔ 0
				0.sin
			✔ 1
				π/2.sin
			✔ 0
				π.sin
			✔ -1
				π3/2.sin
		JS-Math.sin me

	‣ tan
		JS-Math.tan me

	‣ < a:N
		`this < a`

	‣ > a:N
		`this > a`

	‣ ≤ a:N
		`this <= a`

	‣ ≥:N
		`this >= a`

	‣ + a:N
		`this + a`

	‣ - a:N
		`this - a`

	‣ × a:N
		`this * a`

	‣ ÷ divisor:N
		`this / divisor`

	‣ whole-÷ divisor:N
		(÷ divisor).floor

	‣ negate
		`this`

	# TODO: ≈

	‣ = a
		`(this + 0) === (a + 0)`

	‣ positive?
		> 0
	‣ negative?
		< 0
	‣ zero?
		= 0

	‣ round-down
		JS-Math.floor me

	‣ round-up
		JS-Math.ceil me

	‣ difference a:N
		(- a).abs

	‣ remainder divisor:N
		`me % divisor`

	‣ divisible? divisor:N
		(remainder divisor).zero?

	‣ dec
		- 1

	‣ inc
		+ 1

	‣ ^ power:N
		JS-Math.pow me power

	‣ log-e
		JS-Math.log me

	‣ log base:N
		log-e.÷ base.log-e

	‣ log-10
		log-base 10

	‣ log-2
		log-base 2

	‣ inverse
		1.÷ me

	‣ half
		÷ 2

	‣ twice
		× 2

	‣ square
		× me

	‣ cube
		× square

	‣ square-root
		JS-Math.sqrt me

	‣ cube-root
		JS-Math.pow me (1./ 3)

	‣ nth-root n:N
		^ (n.inverse)

	‣ int?
		= round-down

	#‣ try-divide-evenly
	#	(Option.Some (÷ divisor)).filter _int?

	‣ factorial
		TODO
		#(Range.int 1 inc).fold _×

	‣ min a:N
		(< a).? { me } { a }
	‣ max a:N
		(> a).? { me } { a }

	‣ square-hypoteneuse a:N
		square.+ a.square

	‣ hypoteneuse a:N
		(square-hypoteneuse a).square-root

	‣ crop min:N max:N
		#in
		# min.< max
		(me.min max).max min

	‣ greatest-common-divisor a:N
		(= 0).?
			a
		|
			greatest-common-divisor (a.remainder me)

	‣ least-common-multiple a:N
		(× a).÷ (greatest-common-divisor a)

	‣ binary-or n:N
		`this | n`

	‣ binary-and n:N
		`this & n`

	‣ binary-xor n:N
		`this ^ n`

	‣ binary-not
		`~this`

	‣ binary-shift-left n:N
		`this << n`

	‣ binary-shift-right-signed n:N
		`this >> n`

	‣ binary-shift-right-unsigned n:N
		`this >>> n`

	‣val π/2
		π.÷ 2

	‣val π
		JS-Math,PI

	‣val π3/2
		π.+ π/2

	‣val π2
		π.twice

	‣val E
		JS-Math,E

	‣val Golden-Ratio
		5.square-root.inc.half

	‣val ∞
		`global.Infinity`

	‣val -∞
		∞.negate


export N
