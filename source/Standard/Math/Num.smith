∙ N
	Global@Number.to-class 'Num

∙ JS-Math
	Global@Math

N.do-meta
	doc
		...

	‣ ≈[significant-digits~:N] a:N
		doc
			Whether two I am equal to a to within `significant-digits` digits.
			Delegates to ≈0 when I or a are 0.
		eg
			✔ (1001.≈[3] 1000)
			✔ (1001.≈[4] 1000).¬
			✔ (0.001001.≈[3] 0.001)
			✔ (0.001001.≈[4] 0.001).¬

		∙ significant-digits
			significant-digits~.or
				6

		zero?.?
			a.≈0 significant-digits
		|
			a.zero?.?
				≈0 significant-digits
			|
				∙ avg-mag
					magnitude.average a.magnitude
				∙ n-digits
					avg-mag.log-10.round-down
				∙ scale
					10.^ n-digits
				∙ scaled-me
					÷ scale
				∙ scaled-a
					a.÷ scale
				∙ scaled-diff
					scaled-a.distance scaled-me
				∙ epsilon
					10.^ significant-digits.negate

				scaled-diff.< epsilon

	‣ ≈0 significant-digits:N
		doc
			Whether a number is close to zero;
			it must be 0.00... for sig-figs digits.
		eg
			✔ (0.00999.≈0 2)
			✔ (0.01.≈0 2).¬

		∙ max
			10.^ significant-digits.negate

		magnitude.< max

	‣ average a:N
		doc
			Number in between this and a.
		eg
			✔= 2
				1.average 3

		(+ a).half

	‣ round-towards-0
		doc
			Rounds down if positive, rounds up if negative.
		eg
			✔= 0
				-0.5.round-towards-0
			✔= 0
				0.5.round-towards-0
		how
			TODO: JS-Math.cbrt

		binary-or 0

	‣ round
		doc
			Nearest integer to me.
			Rounds up when halfway between two integers.
		eg
			✔= 0
				-0.5.round
			✔= 1
				0.5.round

		JS-Math.round me

	‣ round-down
		doc
			Highest integer lower than me.
		eg
			✔= -1
				-0.5.round-down
			✔= 0
				0.5.round-down

		JS-Math.floor me

	‣ round-up
		doc
			Lowest integer higher than me.
		eg
			✔= 0
				-0.5.round-up
			✔= 1
				0.5.round-up

		JS-Math.ceil me



	‣ cos
		doc
			If I am an angle (in radians) counter-clockwise from +x, the x-value is me.cos.
		eg
			✔.= 1
				0.cos
			✔.≈ 0
				π/2.cos
			✔.≈ -1
				π.cos
			✔.≈ 0
				π3/2.cos

		JS-Math.cos me

	‣ sin
		doc
			If I am an angle (in radians) counter-clockwise from +x, the y-value is me.sin.
		eg
			✔= 0
				0.sin
			✔= 1
				π/2.sin
			✔.≈ 0
				π.sin
			✔= -1
				π3/2.sin
		JS-Math.sin me

	‣ tan
		doc
			Ratio of sin to cos.
		eg
			✔= 0
				0.tan
			✔.≈ 0
				π.tan

		JS-Math.tan me

	‣ acos
		doc
			Number whose cosine I am.
		eg
			✔= π/2
				0.acos
			✔= 0
				1.acos

		JS-Math.acos me

	‣ asin
		doc
			I know it is asin to write this...
			Number whose sin I am.
		eg
			✔= 0
				0.asin
			✔= π/2
				1.asin

		JS-Math.asin me

	‣ atan
		doc
			Number whose tangent I am.
		eg
			✔= 0
				0.atan

		JS-Math.atan me

	‣ < a:N
		doc
			Whether I am closer to -∞ than a.
		eg
			✔ (-1.< 2)
			✔ (1.< 1).¬

		`this < a`

	‣ > a:N
		doc
			Whether I am closer to ∞ than a.
		eg
			✔ (1.> -2)
			✔ (1.> 1).¬

		`this > a`

	‣ ≤ a:N
		doc
			Whether I am < or = a.
		eg
			✔ (1.≤ 1)

		`this <= a`

	‣ ≥ a:N
		doc
			Whether I am > or = a.
		eg
			✔ (1.≥ 1)

		`this >= a`

	‣ + a:N
		doc
			Combination of two counts, one done after the other.
			The method is addition and the result is the sum.
		eg
			✔= 3
				1.+ 2
			✔= -1
				1.+ -2

		`this + a`

	‣ - a:N
		doc
			Number of steps up from `a` to this.
			For number of steps irrespective of direction, use `distance`.
			The method is subtraction and the result is the difference.
		eg
			✔= 1
				3.- 2
			✔= -1
				2.- 3

		`this - a`

	‣ × a:N
		doc
			Sum of this many copies of a.
			The method is multiplication and the result is the product.
		eg
			✔= 6
				2.× 3
			✔= -6
				-2.× 3
			✔= 6
				-2.× -3

		`this * a`

	‣ ÷ divisor:N
		doc
			How many copies of divisor are needed to make me.
			The method is division and the result is the ratio (or quotient).
		eg
			✔= 2
				6.÷ 3
			✔= -2
				-6.÷ 3
			✔= 2
				-6.÷ -3

		`this / divisor`

	‣ whole-÷ divisor:N
		doc
			Like ÷, but any fractional part is rounded down. _Not_ necessarily rounded towards 0.
		eg
			✔= 1
				3.whole-÷ 2
			✔= -2
				3.whole-÷ -2

		(÷ divisor).round-down

	‣ negate
		doc
			Opposite of this number.
		eg
			✔= -1
				1.negate
			✔= 1
				-1.negate

		`-this`

	‣override = a
		`(this + 0) === (a + 0)`

	‣ magnitude
		doc
			Forces me to have a positive sign.
			Also called the absolute value.
		eg
			✔= 1
				1.magnitude
			✔= 1
				-1.magnitude

		JS-Math.abs me

	‣val Not-A-Number
		Global@NaN

	‣ not-a-number?
		Global@Number.isNaN me

	‣ sign
		doc
			1, -1, 0, -0, or `Num.Not-A-Number`.
		eg
			(Bag 1 -1 0 -0).each |n
				✔= n
					n.sign
			✔ Not-A-Number.sign.not-a-number?

		how
			TODO: use Math.sign

		positive?.?
			1
		|
			negative?.?
				-1
			|
				positive-zero?.?
					0
				|
					negative-zero?.?
						-0
					|
						✔ not-a-number?
						N.Not-A-Number

	‣ positive-zero?
		doc
			Whether I am +0 and not -0.
			If you need this info, I don't envy you.
		eg
			✔ 0.positive-zero?
			✔ -0.positive-zero?.¬

		zero?.∧
			inverse.= N.∞

	‣ negative-zero?
		doc
			Whether I am -0 and not +0.
			If you need this info, I don't envy you.
		eg
			✔ -0.negative-zero?
			✔ 0.negative-zero?.¬

		zero?.∧
			inverse.= N.-∞

	‣ positive?
		doc
			Whether this number is > 0.
			All numbers are are one of `positive?`, `negative?`, `zero?`
		eg
			✔ 1.positive?
			✔ 0.positive?.¬
			✔ -1.positive?.¬

		> 0

	‣ negative?
		doc
			Whether this number is < 0.
			All numbers are are one of `positive?`, `negative?`, `zero?`
		eg
			✔ 1.negative?.¬
			✔ 0.negative?.¬
			✔ -1.negative?
		< 0

	‣ zero?
		doc
			Whether this number is 0.
			(Then it is `positive-zero?` or `negative-zero?`.)
		eg
			✔ 0.zero?
			✔ -0.zero?
			✔ 42.zero?.¬

		= 0

	‣ distance a:N
		doc
			Space between two numbers.
			Never returns a negative result.
		eg
			✔= 2
				4.distance 6
			✔= 2
				6.distance 4

		(- a).magnitude

	‣ %
		doc
			Me percent: me out of 100.
		eg
			✔= 1
				100.%

		÷ 100

	‣ remainder divisor:N
		doc
			Remainder after division.
		eg
			✔= 1
				3.remainder 2

		`this % divisor`

	‣ divisible? divisor:N
		doc
			Whether an ingeger number of divisor can add up to me.
		eg
			✔ (4.divisible? 2)
			✔ (4.divisible? -2)
			✔ (3.divisible? 2).¬

		(remainder divisor).zero?

	‣ decrement
		doc
			One less than me.
		eg
			✔= 1.5
				2.5.decrement
		- 1

	‣ increment
		doc
			One more than me.
		eg
			✔= 2.5
				1.5.increment
		+ 1

	‣ ^ power:N
		doc
			The product of `power` of me.
		eg
			✔= 8
				2.^ 3

		JS-Math.pow me power

	‣ log-e
		doc
			The number that `Num.E` must be raised to the power of to reach me.
		eg
			✔= 1
				N.E.log-e

		JS-Math.log me

	‣ log base:N
		doc
			The number that `base` must be raised to the power of to reach me.
		eg
			✔= 3
				8.log 2

		log-e.÷ base.log-e

	‣ log-10
		doc
			Log base 10.
		eg
			✔= 2
				100.log-10

		log 10

	‣ log-2
		doc
			Log base 2.
		eg
			✔= 3
				8.log-2

		log 2

	‣ inverse
		doc
			Multiplicative inverse: This number × me is 1.
		eg
			✔= 0.5
				2.inverse

		1.÷ me

	‣ half
		doc
			Half of me.
		eg
			✔= 2
				4.half

		÷ 2

	‣ twice
		doc
			Me + me.
		eg
			✔= 4
				2.twice

		× 2

	‣ square
		doc
			Me × me.
		eg
			✔= 4
				2.square

		× me

	‣ cube
		doc
			Me × me × me.
		eg
			✔= 8
				2.cube

		× square

	‣ square-root
		doc
			Number whose square is me.
		eg
			✔= 2
				4.square-root
			✔.fails
				-1.square-root

		JS-Math.sqrt me

	‣ cube-root
		doc
			Number whose cube is me.
		eg
			✔= 2
				8.cube-root
			✔.fails
				-1.cube-root
		how
			TODO: JS-Math.cbrt

		JS-Math.pow me 3.inverse

	‣ nth-root n:N
		eg
			✔= 2
				8.nth-root 3
		^ n.inverse

	‣ finite?
		doc
			Am I any number other than `Num.∞` or `Num.-∞`?
		eg
			✔ 42.finite?

		Global@Number.isFinite me

	‣ infinite?
		doc
			`Num.∞` or `Num.-∞`.
		eg
			✔ N.∞.infinite?
			✔ N.-∞.infinite?

		finite?.¬

	‣ natural?
		doc
			Am I a non-negative integer?
		eg
			✔ 0.natural?
			✔ -1.natural?.¬

		integer?.∧
			negative?.¬

	‣ integer?
		doc
			Do I have no fractional parts?
		eg
			✔ 42.integer?
			✔ 0.5.integer?.¬
			✔ ∞.integer?.¬
			✔ N.Not-A-Number.integer?.¬
		how
			TODO: Number.isInteger

		finite?.∧
			(> -9007199254740992).∧
				(< 9007199254740992).∧
					= round-down

	‣ divide-evenly~ divisor:N
		doc
			If possible, an integer which × divisor is me.
		eg
			✔= Opt.None
				3.divide-evenly~ 2
			# TODO
			#✔= (Opt.some 2)
			#	4.divide-evenly~ 2

		Opt.filter (÷ divisor) _integer?

	‣ factorial
		doc
			Product of all integers up to me.
		in
			✔ natural?
		eg
			✔= 6
				3.factorial
			✔= 1
				0.factorial
			✔.fails
				-1.factorial
			✔.fails
				0.5.factorial
		how
			TODO: (Range.int 1 inc).fold _×

		(< 2).?
			1
		|
			× decrement.factorial

	‣ min a:N
		doc
			Lower of me and `a`.
		eg
			✔= 1
				1.min 2

		JS-Math.min me a

	‣ max a:N
		doc
			Higher of me and `a`.
		eg
			✔= 2
				1.max 2

		JS-Math.max me a

	‣ square-hypoteneuse a:N
		doc
			Square of the hypoteneuse.
			Easier to compute than it.
		eg
			✔= 25
				3.square-hypoteneuse 4

		square.+ a.square

	‣ hypoteneuse a:N
		doc
			After moving me far right and `a` far up, the displacement.
		eg
			✔= 5
				3.hypoteneuse 4
		how
			TODO: JS-Math.hypot

		(square-hypoteneuse a).square-root

	‣ crop min:N max:N
		doc
			Forces me in between min and max.
		in
			✔ (min.< max)
		eg
			✔= 1
				0.crop 1 2
			✔= 2
				3.crop 1 2
			✔= 1.5
				1.5.crop 1 2

		(me.min max).max min

	‣ greatest-common-divisor a:N
		doc
			Highest integer that both I and `a` are divisible by.
		in
			✔ natural?
			✔ a.natural?
		eg
			✔= 6
				12.greatest-common-divisor 18
		out
			res.divisible? me
			res.divisible? a

		(a.= 0).?
			me
		|
			a.greatest-common-divisor (remainder a)

	‣ least-common-multiple a:N
		doc
			Lowest integer that both I and `a` are factors of.
		in
			✔ natural?
			✔ a.natural?
		out
			me.divisible? res
			a.divisible? res
		eg
			✔= 18
				6.least-common-multiple 9

		(× a).÷ (greatest-common-divisor a)

	‣ binary-or n:N
		`this | n`

	‣ binary-and n:N
		`this & n`

	‣ binary-xor n:N
		`this ^ n`

	‣ binary-not
		`~this`

	‣ binary-shift-left n:N
		`this << n`

	‣ binary-shift-right-signed n:N
		`this >> n`

	‣ binary-shift-right-unsigned n:N
		`this >>> n`

	‣val π/2
		π.÷ 2

	‣val π
		JS-Math@PI

	‣val π3/2
		π.+ π/2

	‣val π2
		π.twice

	‣val E
		JS-Math@E

	‣val Golden-Ratio
		5.square-root.inc.half

	‣val ∞
		Global@Infinity

	‣val -∞
		∞.negate



export N
