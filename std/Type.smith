#TODO: init

use ./Singleton

∙ T
	`_prelude.Type`

∙ defs |

	‣ 'method |name
		∙ p
			proto
		`p[name]`

	‣ 'alias |old-name new-name
		∙ old
			old-name
		‣ new-name
			`this[old].apply(this, arguments)`

	‣ 'read |name
		‣ name
			`this['_prop_' + name]`

	read 'name
	read 'super
	read 'proto

	‣ 'self
		`this`

	‣ 'toString
		"<Type {name}>"


	‣ 'static |name value
		`this[name] = value`

	‣ 'subsumes? |obj
		`obj['is-a-id-' + this.__id]()`

	‣ 'sub-type-id? |typeid
		`this.__id == typeid || this.__parents.some(function(parent) {
			return parent['_sub-type-id?'](typeid)
		})`

	‣ 'sub-type? |type
		`true` #`(this === type) || ???`


	# TODO:
	# does Singleton

	‣ '‣‣ (Singleton.method '‣‣)
	‣ 'val (Singleton.method 'val)

	‣ '‣type |name do-to
		∙ type
			T name
		∙ doto
			do-to

		`(doto == null) ? null : type.do(doto)`
		type

	‣ '‣object |name do-to
		∙ obj
			Singleton name
		∙ doto
			do-to
		#`(doto != null) ? obj.do(doto) : null`
		obj.do do-to

		obj


defs.unbound.call T

#{
∙ fff |
	=+of |name
		∙ type
			Type name
		type.do
			is Singleton
			+name
				name
		∙ single
			type.of
		single

`fff.__unBound.call(Singleton)`
}#

export T
