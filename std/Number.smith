use ./Type
use ./Object
use ./Bag
use ./Fun
use ./Option

∙ N
	`global.Number`.to-type

∙ Math
	`global.Math`

N.do
	(Bag 'round 'abs 'acos 'asin 'atan 'cos 'sin 'tan).each |name
		me.‣ name (Fun.from-JS "return Math.{name}(this)")

	‣ < a:N
		`this < a`

	‣ > a:N
		`this > a`

	‣ ≤ a:N
		`this <= a`

	‣ ≥:N
		`this >= a`

	‣ + a:N
		`this + a`

	‣ - a:N
		`this - a`

	‣ × a:N
		`this * a`

	‣ ÷ divisor:N
		`this / divisor`

	‣ // divisor:N
		(÷ divisor).floor

	‣ negate
		`this`

	# TODO: ≈

	‣ = a
		`(this + 0) === (a + 0)`

	‣ positive?
		> 0
	‣ negative?
		< 0
	‣ zero?
		= 0

	‣ round-down
		Math.floor me

	‣ round-up
		Math.ceil me

	‣ difference a:N
		(- a).abs

	‣ remainder divisor:N
		`me % divisor`

	‣ divisible? divisor:N
		(remainder divisor).zero?

	‣ dec
		- 1

	‣ inc
		+ 1

	‣ ^ power:N
		Math.pow me power

	‣ log-e
		Math.log me

	‣ log base:N
		log-e.÷ base.log-e

	‣ log-10
		log-base 10

	‣ log-2
		log-base 2

	‣ inverse
		1.÷ me

	‣ half
		÷ 2

	‣ twice
		× 2

	‣ square
		× me

	‣ cube
		× square

	‣ square-root
		`Math.sqrt(this)`

	‣ cube-root
		`Math.pow(this, 1/3)`

	‣ nth-root n:N
		^ (n.inverse)

	‣ int?
		= round-down

	‣ try-divide-evenly
		(Option.Some (÷ divisor)).filter _int?

	‣ factorial
		TODO
		#(Range.int 1 inc).fold _×

	‣ min a:N
		(< a).? { me } { a }
	‣ max a:N
		(> a).? { me } { a }

	‣ square-hypoteneuse a:N
		square.+ a.square

	‣ hypoteneuse a:N
		(square-hypoteneuse a).square-root

	‣ crop min:N max:N
		#in
		# min.< max
		(me.min max).max min

	‣ greatest-common-divisor a:N
		(= 0).?
			a
		|
			greatest-common-divisor (a.remainder me)

	‣ least-common-multiple a:N
		(× a).÷ (greatest-common-divisor a)

	‣ binary-or n:N
		`this | n`

	‣ binary-and n:N
		`this & n`

	‣ binary-xor n:N
		`this ^ n`

	‣ binary-not
		`~this`

	‣ binary-shift-left n:N
		`this << n`

	‣ binary-shift-right-signed n:N
		`this >> n`

	‣ binary-shift-right-unsigned n:N
		`this >>> n`

	‣val Pi
		`Math.PI`

	‣val Pi2
		Pi.twice

	‣val E
		`Math.E`

	‣val Golden-Ratio
		5.square-root.inc.half

	‣val ∞
		`global.Infinity`

	‣val -∞
		∞.negate


export N
