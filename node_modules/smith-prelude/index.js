Function.prototype.unbound = function() {
	if (this._unbound == null)
		return this;
	else {
		var u = this._unbound;
		u._meta = this._meta;
		return u;
	}
}

Function.prototype['to-type'] = function() {
	if (this['_to-type'] == null)
		this['_to-type'] = new constructType(this.name, this.prototype);
	return this['_to-type'];
}

var next_type_id = 0;

var constructType = function(name, proto) {
	if (typeof name !== 'string')
		throw new Error('?');

	this._id =
		next_type_id++;
	this._name =
		name;

	if (proto == Object.prototype)
	{
		this._super = null;
		this._proto = proto;
	}
	else
	{
		this._super =
			Object['to-type']();
		this._proto =
			(proto == null) ? Object.create(this._super._proto) : proto;
	}

	var me = this;
	this._proto.type =
		function() { return me };
	this._proto['__is-a-id-' + this._id] = true;

	this._any_defines =
		false;
};
constructType.prototype = {};

Type = new constructType('Type', constructType.prototype);


Type._proto['‣'] = function(name, method) {
	this._proto[name] = method.unbound();
	this._any_defines = true;
};

Type['‣']('is', function(superType) {
	//Only method should be 'type'
	if (Object.keys(this._proto) > 1)
		throw new Error('is must be first, already have' + Object.keys(this._proto));

	this._super = superType['to-type']();

	newProto = Object.create(this._super.proto());
	newProto.type = this._proto.type;
	this._proto = newProto;
});

Type['‣']('of', function() {
	var obj = Object.create(this._proto);
	this._proto.construct.apply(obj, Array.prototype.slice.call(arguments));
	return obj;
});

Type['‣']('to-type', function() { return this; });

Type['‣']('construct', constructType);

Type['‣']('export', function(value) {
	this.__exported = value;
});


var bind = function(object, name) {
	var x = object[name];
	if (x == null)
		throw new Error("Object " + object + " has no method " + name);
	if (x instanceof Function)
		return x.unbound().bind(object);
	else
		throw new Error(
			"Member '" + name + "' of " + object + " is not a function.");
}

/* Used to wrap files. */
var type = function(name, func) {
	if (!(func instanceof Function))
		throw new Error('?' + func)

	var type = Type.of(name);

	func.call(type);

	if (type.__exported != null)
		return type.__exported;
	else
		return type;
};

var string = function() {
	return Array.prototype.join.call(arguments, '');
}

var checkExists = function(name, a) {
	if (a == null)
		throw new Error("Object " + name + " does not exist.");
}

Type['‣']('check', function(name, a) {
	checkExists(name, a);
	if (!this['subsumes?'](a))
		throw new Error('' + name + ' is not a ' + this + '; is ' + a)
});

var Meta = Type['of']('Meta');
Meta['‣']('construct', function(meta) {
	this._doc = meta._doc;
	this._in = meta._in;
	this._out = meta._out;
	this._eg = meta._eg;
	this._how = meta._how;
})

var fun = function(delegate, unbound, meta) {
	var bound = unbound.bind(delegate);
	bound._unbound = unbound;
	bound._meta = Meta.of(meta);
	return bound;
}

module.exports = {
	fun: fun,
	bind: bind,
	module: module,
	string: string,
	type: type,
	checkExists: checkExists,
	Type: Type,
	Meta: Meta
};
