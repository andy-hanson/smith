var fun = function(delegate, unbound) {
	var bound = unbound.bind(delegate);
	bound.meta = {};
	bound.__unbound = unbound;
	return bound;
}

Function.prototype.unbound = function() {
	return (this.__unbound == null) ? this : this.__unbound;
}

Function.prototype.toType = function() {
	if (this.__type == null)
		this.__type = new constructType(this.name, this.prototype);
	return this.__type;
}

var next_type_id = 0;

var constructType = function(name, proto) {
	if (typeof name !== 'string')
		throw new Error('?');

	this._prop_id =
		next_type_id++;
	this._prop_name =
		name;

	if (proto == Object.prototype)
	{
		this._prop_super = null;
		this._prop_proto = proto;
	}
	else
	{
		//this._prop_super =
		//	(superType == null) ? Object.toType() : superType;
		this._prop_super =
			Object.toType();

		this._prop_proto =
			(proto == null) ? Object.create(this._prop_super._prop_proto) : proto;
	}

	var me = this;
	this._prop_proto.type =
		function() { return me };
	this._prop_proto['__is-a-id-' + this._prop_id] = true;

	this._any_defines =
		false;
};
constructType.prototype = {};

Type = new constructType('Type', constructType.prototype);


Type._prop_proto['‣'] = function(name, method) {
	this._prop_proto[name] = method.unbound();
	this._any_defines = true;
};

Type['‣']('is', function(superType) {
	//Only method should be 'type'
	if (Object.keys(this._prop_proto) > 1)
		throw new Error('is must be first, already have' + Object.keys(this._prop_proto));

	this._prop_super = superType.toType();

	newProto = Object.create(this._prop_super.proto());
	newProto.type = this._prop_proto.type;
	this._prop_proto = newProto;
});

Type['‣']('of', function() {
	var obj = Object.create(this._prop_proto);
	this._prop_proto.construct.apply(obj, Array.prototype.slice.call(arguments));
	return obj;
});

Type['‣']('toType', function() { return this; });

Type['‣']('construct', constructType);

Type['‣']('export', function(value) {
	this.__exported = value;
});


var bind = function(object, name) {
	var x = object[name];
	if (x == null)
		throw new Error("Object " + object + " has no method " + name);
	if (x instanceof Function)
		return x.unbound().bind(object);
	else
		throw new Error(
			"Member '" + name + "' of " + object + " is not a function.");
}

/* Used to wrap files. */
var type = function(name, func) {
	if (!(func instanceof Function))
		throw new Error('?' + func)

	var type = Type.of(name);

	func.call(type);

	if (type.__exported != null)
		return type.__exported;
	else
		return type;
};

var string = function() {
	return Array.prototype.join.call(arguments, '');
}

var checkExists = function(name, a) {
	if (a == null)
		throw new Error("Object " + name + " does not exist.");
}

Type['‣']('check', function(name, a) {
	checkExists(name, a)
	if (!this['subsumes?'](a))
		throw new Error('' + name + ' is not a ' + this + '; is ' + a)
});

module.exports = {
	fun: fun,
	bind: bind,
	module: module,
	string: string,
	type: type,
	checkExists: checkExists,
	Type: Type
};
